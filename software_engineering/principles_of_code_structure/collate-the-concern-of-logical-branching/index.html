<!DOCTYPE html>
<html lang="en">

  <head>
    <title>Collate The Concern Of Logical Branching | Explicator</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="/../../essay.css">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet"> 
  </head>
  
  <body>
  
    
    

    <header style="background: steelblue">
      <h1 class="title">Collate The Concern Of Logical Branching</h1>
      <p class="subtitle"><strong>2022-12-19</strong></p>
    </header>

    <nav>
      <h3 style="text-align: center;">Navigation Links</h3>
    
      
      <p><a style="padding-left: 1em;" href="https://natlund.github.io/">Home Page</a></p>

      
        
        <p><a style="padding-left: 2em;" href="https://natlund.github.io/software_engineering/">Software Engineering</a></p>
      
        
        <p><a style="padding-left: 3em;" href="https://natlund.github.io/software_engineering/principles_of_code_structure/">Principles Of Code Structure</a></p>
      
            
      <hr>
      
      <p><a style="padding-left: 1em;" href="https://natlund.github.io/software_engineering/principles_of_code_structure/">Principles Of Code Structure</a></p>

      <ol>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/readability/">Readability</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/elementary-code-structures/">Elementary Code Structures</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/art-of-abstraction/">The Art Of Abstraction</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/platinum-rule-of-thumb/">The Platinum Rule Of Thumb</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/separation-of-concerns/">Separation Of Concerns</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/separate-inherent-and-collateral-complexity/">Separate Inherent And Collateral Complexity</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/separation-of-functions-and-state/">Separation Of Functions And State</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/distinguish-algorithmlike-from-datalike-code/">Distinguish Algorithm-like From Data-like Code</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/separate-input-output-from-computation/">Separate Input&#x2F;Output From Computation</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/separate-business-logic-from-mechanical-work/">Separate Business Logic From Mechanical Work</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/collate-the-concern-of-logical-branching/">Collate The Concern Of Logical Branching</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/coupling/">Coupling</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/taxonomy-of-connections/">Taxonomy Of Connections</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/coupling-by-direct-connection/">Coupling By Direct Connection</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/coupling-by-dependency-injection/">Coupling By Dependency Injection</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/coupling-by-inheritance/">Coupling By Inheritance</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/coupling-summary/">Coupling Summary</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/coupling-modules-into-a-structure/">Coupling Modules Into A Structure</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/make-execution-flow-obvious/">Make Execution Flow Obvious</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/data-flow-should-follow-execution-flow/">Data Flow Should Follow Execution Flow</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/interfaces/">Interfaces - The Glue That Connects</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/miscellaneous-advice/">Miscellaneous Advice</a>
          </li>
        
          <li>
            <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/thinking-like-an-engineer/">Thinking Like An Engineer</a>
          </li>
        
      </ol>
      
      <hr>

      <p style="padding-left: 1em;">Collate The Concern Of Logical Branching</p>
    
        
        <ul>
        
            <li>
                <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/collate-the-concern-of-logical-branching/#collate-the-concern-of-logical-branching">Collate The Concern Of Logical Branching</a>
                
                    <ul>
                        
                            <li>
                                <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/collate-the-concern-of-logical-branching/#make-branching-explicit">Make Branching Explicit</a>
                            </li>
                        
                            <li>
                                <a href="https://natlund.github.io/software_engineering/principles_of_code_structure/collate-the-concern-of-logical-branching/#use-polymorphism-to-eliminate-logical-branching">Use Polymorphism To Eliminate Logical Branching</a>
                            </li>
                        
                    </ul>
                
            </li>
        
        </ul>
        
    </nav>

    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
           
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    
        
          

    

    <div class="previous_next_header">
        <p>
        
            <a style="float: left;" href="https://natlund.github.io/software_engineering/principles_of_code_structure/separate-business-logic-from-mechanical-work/">Previous: Separate Business Logic From Mechanical Work</a>
        

        
            <a style="float: right;" href="https://natlund.github.io/software_engineering/principles_of_code_structure/coupling/">Next: Coupling</a>
        
       </p>
    </div>

    <article class="essay">
        <h1 id="collate-the-concern-of-logical-branching">Collate The Concern Of Logical Branching</h1>
<p>If your code requires a logical branch, try to do it only once.  Your code will be much cleaner and easier to read.</p>
<p>Making the <em>same</em> logical branch (i.e. exactly the same logical conditions) in <em>multiple</em> places should be considered an anti-pattern, or at least a code smell.  The resulting code is always cluttered and messy.  Try to refactor it to have only one occurrence of the logical branch.</p>
<p>In graphical form, the left hand pattern is much easier to understand than the right hand pattern:</p>
<div align="center">
<svg width="600" height="640">
    <line x1="100" y1="20" x2="100" y2="120" stroke="red" stroke-width="8"/>
    <line x1="100" y1="120" x2="20" y2="220" stroke="red" stroke-width="8"/>
    <line x1="100" y1="120" x2="180" y2="220" stroke="red" stroke-width="8"/>
    <line x1="20" y1="220" x2="20" y2="620" stroke="red" stroke-width="8"/>
    <line x1="180" y1="220" x2="180" y2="620" stroke="red" stroke-width="8"/>
    <circle cx="100" cy="20" r="20" fill="blue"/>
    <polygon points="100,90 70,120 100,150 130,120" fill="lime" stroke="black"/>
    <circle cx="20" cy="220" r="20" fill="blue"/>
    <circle cx="20" cy="320" r="20" fill="blue"/>
    <circle cx="20" cy="420" r="20" fill="blue"/>
    <circle cx="20" cy="520" r="20" fill="blue"/>    
    <circle cx="20" cy="620" r="20" fill="blue"/>    
    <circle cx="180" cy="220" r="20" fill="blue"/>
    <circle cx="180" cy="320" r="20" fill="blue"/>
    <circle cx="180" cy="420" r="20" fill="blue"/>
    <circle cx="180" cy="520" r="20" fill="blue"/>
    <circle cx="180" cy="620" r="20" fill="blue"/>
    <line x1="500" y1="20" x2="500" y2="120" stroke="red" stroke-width="8"/>
    <line x1="500" y1="120" x2="420" y2="220" stroke="red" stroke-width="8"/>
    <line x1="500" y1="120" x2="580" y2="220" stroke="red" stroke-width="8"/>
    <line x1="420" y1="220" x2="500" y2="320" stroke="red" stroke-width="8"/>
    <line x1="580" y1="220" x2="500" y2="320" stroke="red" stroke-width="8"/>
    <line x1="500" y1="320" x2="500" y2="420" stroke="red" stroke-width="8"/>
    <line x1="500" y1="420" x2="420" y2="520" stroke="red" stroke-width="8"/>
    <line x1="500" y1="420" x2="580" y2="520" stroke="red" stroke-width="8"/>
    <line x1="420" y1="520" x2="500" y2="620" stroke="red" stroke-width="8"/>
    <line x1="580" y1="520" x2="500" y2="620" stroke="red" stroke-width="8"/>
    <circle cx="500" cy="20" r="20" fill="blue"/>
    <polygon points="500,90 470,120 500,150 530,120" fill="lime" stroke="black"/>
    <circle cx="420" cy="220" r="20" fill="blue"/>
    <circle cx="500" cy="320" r="20" fill="blue"/>
    <polygon points="500,390 470,420 500,450 530,420" fill="lime" stroke="black"/>
    <circle cx="420" cy="520" r="20" fill="blue"/>    
    <circle cx="580" cy="220" r="20" fill="blue"/>
    <circle cx="580" cy="520" r="20" fill="blue"/>    
    <circle cx="500" cy="620" r="20" fill="blue"/>
</svg>
</div>
<h3 id="make-branching-explicit">Make Branching Explicit</h3>
<p>One (misguided) way to save a line of code is to write a logical branch like this:</p>
<pre data-lang="py" style="background-color:#2b303b;color:#c0c5ce;" class="language-py "><code class="language-py" data-lang="py"><span>x = </span><span style="color:#d08770;">0  </span><span style="color:#65737e;"># Default value.
</span><span style="color:#b48ead;">if </span><span>some_condition is </span><span style="color:#d08770;">True</span><span>:
</span><span>    x = </span><span style="color:#d08770;">1
</span></code></pre>
<p>Now, does this <em>look</em> like a logical branch?  At first glance, the reader notices that a variable is set, then mutated <em>if</em> a particular condition is true.  The pattern is: 1) Do some work. 2) If a condition is true, then <em>undo and redo</em> the work.</p>
<p>What does mutating a variable have to do with logical branching?  The answer is: <em>nothing</em>.  This mutation is not necessary to achieve logical branching.  In fact, while all languages allow logical branching, there are modern languages with an emphasis on safety that strongly discourage mutation, or even forbid it.  (Eg. Rust, and functional languages.)  Mutation typically makes code harder to reason about, so should be kept to an absolute minimum.</p>
<p>The <em>meaning</em> of the code is: make a binary logical choice.  Therefore, the code should reflect that meaning as directly as possible.  The traditional <code>if else</code> construction does this perfectly:</p>
<pre data-lang="py" style="background-color:#2b303b;color:#c0c5ce;" class="language-py "><code class="language-py" data-lang="py"><span style="color:#b48ead;">if </span><span>some_condition is </span><span style="color:#d08770;">True</span><span>:
</span><span>    x = </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">else</span><span>:
</span><span>    x = </span><span style="color:#d08770;">0
</span></code></pre>
<p>The other benefit of the traditional <code>if else</code> is that the code at the same <em>logical level</em> (down one branch or the other) is at the same <em>indentation level</em>.</p>
<p>In the diagrams below, the <em>meaning</em> of the code is shown as the tree with red links, and the <em>execution flow</em> of the code is shown as the black arrows.</p>
<div align="center">
<svg width="600" height="260">
    <defs>
        <marker
            id="arrowhead_heavy"
            markerWidth="10" markerHeight="8" 
            refX="8" refY="4"
            orient="auto"
        >
            <polygon points="2 4, 0 8, 10 4, 0 0"/>
        </marker>
        <marker
            id="arrowhead"
            markerWidth="7" markerHeight="7" 
            refX="6" refY="3.5"
            orient="auto"
        >
            <polygon points="2.33 3.5, 0 7, 7 3.5, 0 0"/>
        </marker>
    </defs>
    <-- Left hand tree -->
    <line x1="100" y1="20" x2="100" y2="120" stroke="red" stroke-width="8"/>
    <line x1="100" y1="120" x2="20" y2="220" stroke="red" stroke-width="8"/>
    <line x1="100" y1="120" x2="180" y2="220" stroke="red" stroke-width="8"/>
    <circle cx="100" cy="20" r="20" fill="blue"/>
    <polygon points="100,90 70,120 100,150 130,120" fill="lime" stroke="black"/>
    <circle cx="20" cy="220" r="20" fill="blue"/>
    <circle cx="180" cy="220" r="20" fill="blue"/>
    <text x="0" y="260">x = 0</text>
    <text x="160" y="260">x = 1</text>
    <--   Flow arrows -->
    <line x1="20" y1="0" x2="20" y2="195" stroke="black" stroke-width="2" marker-end="url(#arrowhead)"/>
    <line x1="43" y1="217" x2="95" y2="155" stroke="black" stroke-width="2" marker-end="url(#arrowhead)"/>
    <line x1="105" y1="155" x2="155" y2="215" stroke="black" stroke-width="2" marker-end="url(#arrowhead)"/>
    <-- Right hand tree -->
    <line x1="500" y1="20" x2="500" y2="120" stroke="red" stroke-width="8"/>
    <line x1="500" y1="120" x2="420" y2="220" stroke="red" stroke-width="8"/>
    <line x1="500" y1="120" x2="580" y2="220" stroke="red" stroke-width="8"/>
    <circle cx="500" cy="20" r="20" fill="blue"/>
    <polygon points="500,90 470,120 500,150 530,120" fill="lime" stroke="black"/>
    <circle cx="420" cy="220" r="20" fill="blue"/>
    <circle cx="580" cy="220" r="20" fill="blue"/>
    <text x="400" y="260">x = 0</text>
    <text x="560" y="260">x = 1</text>
    <-- Flow arrows -->
    <line x1="530" y1="0" x2="530" y2="115" stroke="black" stroke-width="2" marker-end="url(#arrowhead)"/>
    <line x1="527" y1="127" x2="580" y2="195" stroke="black" stroke-width="2" marker-end="url(#arrowhead)"/>
</svg>
</div>
<p>The left-hand diagram of the code using mutation shows how the code actually traverses one branch of the tree <em>before</em> encountering the conditional.  This disconnect from the semantics of the code has a cognitive cost.  So the 'shorter' method using variable mutation is actually harder to understand.  Don't try to save a single line of code at the expense of readability.  Just use the traditional <code>if else</code> construction.</p>
<h3 id="use-polymorphism-to-eliminate-logical-branching">Use Polymorphism To Eliminate Logical Branching</h3>
<p>Consider this code, a toy example of part of some kind of graphics program.  It may not be realistic, but it illustrates a point.</p>
<pre data-lang="py" style="background-color:#2b303b;color:#c0c5ce;" class="language-py "><code class="language-py" data-lang="py"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Square</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">_init_</span><span>(</span><span style="color:#bf616a;">width</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.width = width
</span><span>
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Circle</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">_init</span><span>(</span><span style="color:#bf616a;">radius</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.radius = radius
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">calculate_total_area_of_shapes</span><span>(</span><span style="color:#bf616a;">shapes</span><span>: list):
</span><span>    total_area = </span><span style="color:#d08770;">0
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>shape </span><span style="color:#b48ead;">in </span><span>shapes:
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">isinstance</span><span>(shape, Square):
</span><span>            total_area += </span><span style="color:#bf616a;">area_of_square</span><span>(shape)
</span><span>
</span><span>        </span><span style="color:#b48ead;">elif </span><span style="color:#96b5b4;">isinstance</span><span>(shape, Circle):
</span><span>            total_area += </span><span style="color:#bf616a;">area_of_circle</span><span>(shape)
</span><span>
</span><span>        </span><span style="color:#b48ead;">else</span><span>:
</span><span>            </span><span style="color:#96b5b4;">print</span><span>(&quot;</span><span style="color:#a3be8c;">Shape not recognised.  Cannot calculate area.</span><span>&quot;)
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>total_area
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">area_of_square</span><span>(</span><span style="color:#bf616a;">square</span><span>: Square):
</span><span>    </span><span style="color:#b48ead;">return </span><span>square.width ** </span><span style="color:#d08770;">2
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">area_of_circle</span><span>(</span><span style="color:#bf616a;">circle</span><span>: Circle):
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">3.141592654 </span><span>* circle.radius ** </span><span style="color:#d08770;">2
</span></code></pre>
<p>The important point to note is the <strong>logical branching</strong> in the function <code>calculate_total_area_of_shapes()</code>.</p>
<p>This example code can also be considered a canonical example of the value of <em>method polymorphism</em>.  Let us rewrite the code to use method polymorphism.</p>
<pre data-lang="py" style="background-color:#2b303b;color:#c0c5ce;" class="language-py "><code class="language-py" data-lang="py"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Square</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">_init_</span><span>(</span><span style="color:#bf616a;">width</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.width = width
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">area</span><span>(</span><span style="color:#bf616a;">self</span><span>):
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">self</span><span>.width ** </span><span style="color:#d08770;">2
</span><span>
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Circle</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">_init_</span><span>(</span><span style="color:#bf616a;">radius</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.radius = radius
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">area</span><span>(</span><span style="color:#bf616a;">self</span><span>):
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">3.141592654 </span><span>* </span><span style="color:#bf616a;">self</span><span>.radius ** </span><span style="color:#d08770;">2
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">calculate_total_area_of_shapes</span><span>(</span><span style="color:#bf616a;">shapes</span><span>: list):
</span><span>    total_area = </span><span style="color:#d08770;">0
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>shape </span><span style="color:#b48ead;">in </span><span>shapes:
</span><span>        total_area += shape.</span><span style="color:#bf616a;">area</span><span>()
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>total_area
</span></code></pre>
<p>The code has been simplified considerably, and is easier to read.  This shows the value of method polymorphism.</p>
<p>But let's dig a little deeper.  Obviously, the two functions for calculating area have been <em>moved</em> to be attached to the data structures they operate on. And the main function <code>calculate_total_area_of_shapes()</code> is drastically simpler because it no longer contains the logical branching.  Was it moved?  Upon inspection, the <strong>logical branching</strong> has apparently completely <strong>disappeared</strong> from our code!  Where did it go? In fact, the logical branching is still inside the compiled (byte) code in the form of look-up table or similar.  Method polymorphism has allowed us remove the logical branching from our source code, where it adds complexity for the human reader, and move it into the compiled code, where it is completely out of our sight, and now the responsibility of the computer.</p>
<p>Removing the complexity of logical branching from our source code is perhaps an under-appreciated aspect of object-oriented techniques such as this.</p>

        
        <p style="text-align: center; font-size: 24pt;"> &#128608 </p>

    
    </article>

    <div class="previous_next_footer">
        <p>
        
            <a style="float: left;" href="https://natlund.github.io/software_engineering/principles_of_code_structure/separate-business-logic-from-mechanical-work/">Previous: Separate Business Logic From Mechanical Work</a>
        

        
            <a style="float: right;" href="https://natlund.github.io/software_engineering/principles_of_code_structure/coupling/">Next: Coupling</a>
        
       </p>
    </div>
    
    <div class="filler"></div>

    <footer>
      <p class="datestamp"><strong>2022-12-19</strong></p>
    </footer>
  
  </body>

</html>
